import socket
import selectors
import server_message_handling

import config
import server_model


class Server:

    def __init__(self, host, port) -> None:
        self.connected_clients: dict[socket.socket, server_model.ConnectedClient] = {}
        self.host = host
        self.port = port

        self.sel = selectors.DefaultSelector()

        self.listening_socket = self._set_listen_socket()
        self.sel.register(self.listening_socket, selectors.EVENT_READ, data=None)

    def _set_listen_socket(self):
        print("Starting server")
        lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        lsock.bind((self.host, self.port))
        lsock.listen()
        print(f"Listening on {self.host}:{self.port}")
        lsock.setblocking(False)
        return lsock

    def _run_event_loop(self):
        try:
            while True:
                events = self.sel.select(timeout=1)
                if not events:
                    check_connections(self.connected_clients)
                    return None
                for key, mask in events:
                    try:
                        if not isinstance(key.fileobj, socket.socket):
                            raise ValueError(
                                f"Non socket type found in events: {key.fileobj}"
                            )
                        if key.data is None:
                            self.accept_connection(key.fileobj)
                        elif isinstance(key.data, server_model.ConnectedClient):
                            assert key.fileobj is key.data.sock
                            return self.service_connection(key.data, mask)
                        else:
                            print(
                                f"WARNING: Unkown data return from selector: \n- {key.__dict__=}, \n- {mask}"
                            )
                            return None
                    except ValueError as e:
                        print(f"ValueError: {e}")
                        return None
        except KeyboardInterrupt:
            print("Caught keyboard interrupt. Closing server.")
            
            self.shutdown_server()
        # finally:
        #     self.shutdown()

    def accept_connection(self, sock: socket.socket):
        print(f"Accepting Connection")
        conn, addr = sock.accept()
        new_client = server_model.ConnectedClient(conn, self.sel)
        self.connected_clients[conn] = new_client
        print(f"Connection accepted with {addr}")
        conn.setblocking(False)


    def service_connection(
        self, client:server_model.ConnectedClient, mask
    ):
        if mask & selectors.EVENT_READ:
            message_content = client.read()
            if not message_content:
                return None
            assert self.connected_clients[client.sock] is not None
            assert isinstance(message_content, str)
            
            return message_content
        if mask & selectors.EVENT_WRITE:
            client.write()

    def shutdown_server(
        self,
    ):
        if self.listening_socket is None:
            print("Error: self.listening_socket is None. Server never started.")
            return
        print("Shutting down server")
        self.sel.close()
        for client in self.connected_clients.values():
            client.close_connection()
        self.listening_socket.shutdown(socket.SHUT_RDWR)
        self.listening_socket.close()
        print("Server shutdown complete")

    def enter_event_loop(self):
        return self._run_event_loop()
    


class ServerApp:

    def __init__(self) -> None:
        HOST = config.SERVER_HOST
        PORT = config.SERVER_PORT

        self.server = Server(HOST, PORT)

        self.connected_clients: dict[socket.socket, server_model.ConnectedClient] = (
            self.server.connected_clients
        )
        self.distributed_fs = server_model.DistributedFS(self.connected_clients)

        while True:
            for client in self.connected_clients.values():
                client.print_responses()

            server_model.DistributedFS.print_conntected_clients(self.distributed_fs)
            user_input = input(get_short_instructions()).strip()
            if user_input == "quit" or user_input == "exit":
                self.server.shutdown_server()
                break
            elif user_input == "help":
                print_help()
            # Lines 131 to 137 were partially generated by GitHub Copilot and then modified by me. This was done out of reflex (rather than incompetence) after I forgot to turn off code-completions and re
            elif user_input.startswith('kick'):
                _, client_id = user_input.split()
                try:
                    client_id = int(client_id)
                except:
                    print(f"client_id {client_id} that was entered is not a valid integer")
                client_found = False
                for sock, client in self.connected_clients.items():
                    if client.client_id == client_id:
                        client_found = True
                        client.close_connection()
                        try:
                            self.connected_clients.pop(sock)
                        except KeyError:
                            pass
                        break
                if not client_found:
                    input(f"Client {client_id} was not found. (press enter to continue)")
            else:
                self.process_user_input(user_input)
                self.server.enter_event_loop()


    def process_user_input(self, user_input:str):
        if not user_input:
            return
        user_input = ('/' + user_input + '/').replace('//', '/')
        _, client_id, path_query = user_input.split('/', 2)
        try:
            client_id = int(client_id)
        except ValueError as e:
            print(e)
            print(f"Path must be of form '/[<client_id>]/<path>. Parser interpretted client_id as {client_id}")
            return
        target_client = self.distributed_fs.get_client_with_id(int(client_id))

        if target_client is None:
            print(f"Client with ID {client_id} not found.")
            return None
        
        path_query = '/' + path_query
        target_client.queue_outgoing_message(path_query)


def check_connections(connected_clients:dict[socket.socket, server_model.ConnectedClient]):
    disconnected_clients = []
    for sock, client in connected_clients.items():
        if not client.is_connected():
            disconnected_clients.append(sock)
    for sock in disconnected_clients:
        print(f"Connection with {client.client_id} closed.")
        del connected_clients[sock]
            


def get_short_instructions():
    s="""
Enter a path, treating the client id as a directory, e.g.:
    $ /1/some_folder
    
Press <ENTER> to refresh, type 'exit' to exit, or 'help' for more info."""
    return s


def print_help():
    s="""
Commands:
  <path>            treat <client id> as a directory name.
  exit, quit        quit the program and shutdown the server.
  <ENTER>           refresh the client ID list and see any new responses from queried clients.
  kick <client_id>  kick a client from the server.

"""
    print(s)


if __name__ == "__main__":
    ServerApp()
